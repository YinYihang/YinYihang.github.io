<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>aaron.yee</title>
    <link href="https://xinitrc.de/atom.xml" rel="self" />
    <link href="https://xinitrc.de" />
    <id>https://xinitrc.de/atom.xml</id>
    <author>
        <name>Aaron Yee</name>
        <email>yinyhmail@gmail.com</email>
    </author>
    <updated>2015-09-17T00:00:00Z</updated>
    <entry>
    <title>(转) Neural Networks, Manifolds, and Topology</title>
    <link href="https://xinitrc.de/blog/2015/09/17/deep-learning-1.html" />
    <id>https://xinitrc.de/blog/2015/09/17/deep-learning-1.html</id>
    <published>2015-09-17T00:00:00Z</published>
    <updated>2015-09-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>An exciting visualization of deep neural networks.</p>
<!--more-->
<p>Recently, there’s been a great deal of excitement and interest in deep neural networks because they’ve achieved breakthrough results in areas such as computer vision.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<p>However, there remain a number of concerns about them. One is that it can be quite challenging to understand <em>what</em> a neural network is really doing. If one trains it well, it achieves high quality results, but it is challenging to understand how it is doing so. If the network fails, it is hard to understand what went wrong.</p>
<p>While it is challenging to understand the behavior of deep neural networks in general, it turns out to be much easier to explore low-dimensional deep neural networks – networks that only have a few neurons in each layer. In fact, we can create visualizations to completely understand the behavior and training of such networks. This perspective will allow us to gain deeper intuition about the behavior of neural networks observe a connection linking neural networks to an area of mathematics called topology.</p>
<p>A number of interesting things follow from this, including fundamental lower-bounds on the complexity of a neural network capable of classifying certain datasets.</p>
<section id="a-simple-example" class="level2">
<h2>A Simple Example</h2>
<p>Let’s begin with a very simple dataset, two curves on a plane. The network will learn to classify points as belonging to one or the other.</p>
<div class="centerimgcontainer">
<img src="/assets/images/dl1/simple2_data.png" alt="" style="">
</div>
<div class="spaceafterimg">
</div>
<p>The obvious way to visualize the behavior of a neural network – or any machine learning algorithm, for that matter –’s behavior is to simply look at how it classifies every possible data point.</p>
<p>We’ll start with the simplest possible class of neural network, one with only an input layer and an output layer. Such a network simply tries to separate the two classes of data by dividing them with a line.</p>
<div class="centerimgcontainer">
<img src="/assets/images/dl1/simple2_linear.png" alt="" style="">
</div>
<div class="spaceafterimg">
</div>
<p>That sort of network isn’t very interesting. Modern neural networks generally have multiple layers between their input and output, called “hidden” layers. At the very least, they have one.</p>
<div class="centerimgcontainer">
<img src="/assets/images/dl1/example_network.svg" alt="" style="">
<div class="caption">
Diagram of a simple network from Wikipedia
</div>
</div>
<div class="spaceafterimg">
</div>
<p>As before, we can visualize the behavior of this network by looking at what it does to different points in its domain. It separates the data with a more complicated curve than a line.</p>
<div class="centerimgcontainer">
<img src="/assets/images/dl1/simple2_0.png" alt="" style="">
</div>
<div class="spaceafterimg">
</div>
<p>With each layer, the network transforms the data, creating a new <em>representation</em>.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> We can look at the data in each of these representations and how the network classifies them. When we get to the final representation, the network will just draw a line through the data (or, in higher dimensions, a hyper-plane).</p>
<p>In the previous visualization, we looked at the data in its “raw” representation. You can think of that as us look at the input layer. Now we will look at it after it is transformed by the first layer. You can think of this as us looking at the hidden layer.</p>
<p>Each dimension corresponds to the firing of a neuron in the layer.</p>
<div class="centerimgcontainer">
<img src="/assets/images/dl1/simple2_1.png" alt="" style="">
<div class="caption">
The hidden layer learns a representation so that the data is linearly seperable
</div>
</div>
<div class="spaceafterimg">
</div>
</section>
<section id="continuous-visualization-of-layers" class="level2">
<h2>Continuous Visualization of Layers</h2>
<p>In the approach outlined in the previous section, we learn to understand networks by looking at the representation corresponding to each layer. This gives us a discrete list of representations.</p>
<p>The tricky part is in understanding how we go from one to another. Thankfully, neural network layers have nice properties that make this very easy.</p>
<p>There are a variety of different kinds of layers used in neural networks. We will talk about tanh layers for a concrete example. A tanh layer <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>tanh</mi><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mi>x</mi><mo>+</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\tanh(Ax+b)</annotation></semantics></math> consists of:</p>
<ol type="1">
<li>A linear transformation by the matrix <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math></li>
<li>A translation by the vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math></li>
<li>Point-wise application of tanh.</li>
</ol>
<p>We can visualize this as a continuous transformation, as follows:</p>
<div class="centerimgcontainer">
<img src="/assets/images/dl1/1layer.gif" alt="Gradually applying a neural network layer" style="">
</div>
<div class="spaceafterimg">
</div>
<p>The story is much the same for other standard layers, that consist of an affine transformation followed by pointwise application of a monotone activation function.</p>
<p>We can apply this technique to understand more complicated networks. For example, the following network classifies two spirals that are slightly entangled, using many layers.</p>
<div class="centerimgcontainer">
<img src="/assets/images/dl1/spiral.1-2.2-2-2-2-2-2.gif" alt="" style="">
</div>
<div class="spaceafterimg">
</div>
<p>And the following network fails to classify two spirals that are more entangled, using many layers.</p>
<div class="centerimgcontainer">
<img src="/assets/images/dl1/spiral.2.2-2-2-2-2-2-2.gif" alt="" style="">
</div>
<div class="spaceafterimg">
</div>
<p>It is worth explicitly noting here that these tasks are only somewhat challenging because we are using low-dimensional neural networks. If we were using wider networks, all this would be quite easy.</p>
</section>
<section id="topology-of-tanh-layers" class="level2">
<h2>Topology of tanh Layers</h2>
<p>Each layer stretches and squishes space, but it never cuts, breaks, or folds it. Intuitively, we can see that it preserves topological properties. For example, a set will be connected afterwards if it was before (and vice versa).</p>
<p>Transformation like this, which don’t affect topology, are called homeomorphisms. Formally, they are bijections that are continuous functions both ways.</p>
<p><strong>Theorem</strong>: Layers with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math> inputs and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math> outputs are homeomorphisms, if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math> is non-singular. (Though one needs to be careful about domain and range.)</p>
<p><strong>Proof</strong>: Let’s consider this step by step:</p>
<ol type="1">
<li>Let’s assume <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math> has a non-zero determinant. Then it is a bijective linear function with a linear inverse. Linear functions are continuous. So, multiplying by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math> is a homeomorphism.</li>
<li>Translations are homeomorphisms</li>
<li>tanh (and sigmoid and softplus but not ReLU) are continuous functions with continuous inverses. They are bijections if we are careful about the domain and range we consider. Applying them pointwise is a homemorphism</li>
</ol>
<p>Thus, if W has a non-zero determinant, our layer is a homeomorphism. ∎</p>
<p>This result continues to hold if we compose arbitrarily many of these layers together.</p>
</section>
<section id="topology-and-classification" class="level2">
<h2>Topology and Classification</h2>
<div class="floatrightimgcontainer">
<img src="/assets/images/dl1/topology_base.png" alt="" style="">
<div class="caption">
A is red, B is blue
</div>
</div>
<div class="spaceafterimg">
</div>
<p>Consider a two dimensional dataset with two classes <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi><mo>⊂</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">A, B \subset \mathbb{R}^2</annotation></semantics></math>:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo stretchy="false" form="prefix">|</mo><mi>d</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo><mo>&lt;</mo><mn>1</mn><mo>/</mo><mn>3</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">A = \{x | d(x,0) &lt; 1/3\}</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo stretchy="false" form="prefix">|</mo><mn>2</mn><mo>/</mo><mn>3</mn><mo>&lt;</mo><mi>d</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo><mo>&lt;</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">B = \{x | 2/3 &lt; d(x,0) &lt; 1\}</annotation></semantics></math></p>
<p><strong>Claim</strong>: It is impossible for a neural network to classify this dataset without having a layer that has 3 or more hidden units, regardless of depth.</p>
<p>As we discussed previously, classification with a sigmoid unit or a softmax layer would be equivalent to trying to find a hyperplane (or in this case a line) that separates <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>.</p>
<p>Unfortunately, with only two hidden units, a network is topologically doomed to failure on this dataset. We can watch it struggle and try to learn a way to do this:</p>
<div class="centerimgcontainer">
<img src="/assets/images/dl1/topology_2D-2D_train.gif" alt="" style="">
<div class="caption">
For this network, hard work isn’t enough.
</div>
</div>
<div class="spaceafterimg">
</div>
<p>(It’s actually able to achieve ~80% classification accuracy.)</p>
<p>This example only had one hidden layer, but it would fail regardless.</p>
<p><strong>Proof</strong>: Either each layer is a homeomorphism, or the layer’s weight matrix has determinant 0. If it is a homemorphism, A is still surrounded by B, and a line can’t separate them. But suppose it has a determinant of 0: then the dataset gets collapsed on some axis. Since we’re dealing with something homeomorphic to the original dataset, A is surrounded by B, and collapsing on any axis means we will have some points of A and B mix and become impossible to distinguish between. ∎</p>
<p>If we add a third hidden unit, the problem becomes trivial. The neural network learns the following representation:</p>
<div class="centerimgcontainer">
<img src="/assets/images/dl1/topology_3d.png" alt="" style="">
</div>
<div class="spaceafterimg">
</div>
<p>With this representation, we can separate the datasets with a hyperplane.</p>
<p>To get a better sense of what’s going on, let’s consider an even simpler dataset that’s 1-dimensional:</p>
<div class="floatrightimgcontainer">
<img src="/assets/images/dl1/topology_1d.png" alt="" style="">
</div>
<div class="spaceafterimg">
</div>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false" form="prefix">[</mo><mo>−</mo><mfrac><mn>1</mn><mn>3</mn></mfrac><mo>,</mo><mfrac><mn>1</mn><mn>3</mn></mfrac><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">A = [-\frac{1}{3}, \frac{1}{3}]</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mo stretchy="false" form="prefix">[</mo><mo>−</mo><mn>1</mn><mo>,</mo><mo>−</mo><mfrac><mn>2</mn><mn>3</mn></mfrac><mo stretchy="false" form="postfix">]</mo><mo>∪</mo><mo stretchy="false" form="prefix">[</mo><mfrac><mn>2</mn><mn>3</mn></mfrac><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">B = [-1, -\frac{2}{3}] \cup [\frac{2}{3}, 1]</annotation></semantics></math></p>
<p>Without using a layer of two or more hidden units, you can’t classify this dataset. But if you use one with two units, we learn to represent the data as a nice curve that allows us to separate the data:</p>
<div class="centerimgcontainer">
<img src="/assets/images/dl1/topology_1D-2D_train.gif" alt="" style="">
</div>
<div class="spaceafterimg">
</div>
<p>What’s happening? One hidden unit learns to fire when <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>&gt;</mo><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">x &gt; -\frac{1}{2}</annotation></semantics></math> and one learns to fire when <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>&gt;</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">x &gt; \frac{1}{2}</annotation></semantics></math>. When the first one fires, but not the second, we know that we are in A.</p>
</section>
<section id="the-manifold-hypothesis" class="level2">
<h2>The Manifold Hypothesis</h2>
<p>Is this relevant to real world data sets, like image data? If you take the manifold hypothesis really seriously, I think it bares consideration.</p>
<p>The manifold hypothesis is that natural data forms lower-dimensional manifolds in its embedding space. There are both theoretical<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> and experimental<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> reasons to believe this to be true. If you believe this, then the task of a classification algorithm is fundamentally to separate a bunch of tangled manifolds.</p>
<p>In the previous examples, one class completely surrounded another. However, it doesn’t seem very likely that the dog image manifold is completely surrounded by the cat image manifold. But there are other, more plausible topological situations that could still pose an issue, as we will see in the next section.</p>
</section>
<section id="links-and-homotopy" class="level2">
<h2>Links And Homotopy</h2>
<p>Another interesting dataset to consider is two linked tori, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>.</p>
<div class="centerimgcontainer">
<img src="/assets/images/dl1/link.png" alt="" style="">
</div>
<div class="spaceafterimg">
</div>
<p>Much like the previous datasets we considered, this dataset can’t be separated without using <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math> dimensions, namely a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>4</mn><annotation encoding="application/x-tex">4</annotation></semantics></math>th dimension.</p>
<p>Links are studied in knot theory, an area of topology. Sometimes when you see a link, it isn’t immediately obvious whether it’s an unlink (a bunch of things that are tangled together, but can be separated by continuous deformation) or not.</p>
<div class="bigcenterimgcontainer">
<img src="/assets/images/dl1/unlink-2spiral.png" alt="" style="">
<div class="caption">
A relatively simple unlink.
</div>
</div>
<div class="spaceafterimg">
</div>
<p>If a neural network using layers with only 3 units can classify it, then it is an unlink. (Question: Can all unlinks be classified by a network with only 3 units, theoretically?)</p>
<p>From this knot perspective, our continuous visualization of the representations produced by a neural network isn’t just a nice animation, it’s a procedure for untangling links. In topology, we would call it an <em>ambient isotopy</em> between the original link and the separated ones.</p>
<p>Formally, an ambient isotopy is between manifolds <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math> is a continuous function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo><mo>×</mo><mi>X</mi><mo accent="false">→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">F: [0,1] \times X \to Y</annotation></semantics></math> such that each <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>t</mi></msub><annotation encoding="application/x-tex">F_t</annotation></semantics></math> is a homeomorphism from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math> to its range, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mn>0</mn></msub><annotation encoding="application/x-tex">F_0</annotation></semantics></math> is the identity function, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mn>1</mn></msub><annotation encoding="application/x-tex">F_1</annotation></semantics></math> maps <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>. That is, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>t</mi></msub><annotation encoding="application/x-tex">F_t</annotation></semantics></math> continuously transitions from mapping <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> to itself to mapping <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>.</p>
<p><strong>Theorem</strong>: There is an ambient isotopy between the input and a network layer’s representation if: a) W isn’t singular, b) you are willing to permute the neurons in the hidden layer, and c) there is more than 1 hidden unit.</p>
<p><strong>Proof</strong>: Again, we consider each stage of the network individually:</p>
<ol type="1">
<li>The linear transformation is, in fact, the hardest part. In order for this to be possible, we need <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math> to have a positive determinant. Our premise is that it isn’t zero, and we can flip the sign if it is negative by switching two of the hidden neurons, so we can guarantee the determinant is positive. The space of positive determinant matrices is path-connected, so there exists <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>:</mo><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo><mo accent="false">→</mo><mi>G</mi><msub><mi>L</mi><mi>n</mi></msub><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">p: [0,1] \to GL_n(\mathbb{R})</annotation></semantics></math> such that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>I</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">p(0) = Id</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">p(1) = W</annotation></semantics></math>. We can continually transition from the identity function to the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math> transformation with the function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo accent="false">→</mo><mi>p</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x \to p(t)x</annotation></semantics></math></li>
<li>We can continually transition from the identity function to the b translation with the function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo accent="false">→</mo><mi>x</mi><mo>+</mo><mi>t</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">x \to x + tb</annotation></semantics></math></li>
<li>We can continually transition from the identity function to the pointwise use of σ with the function: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo accent="false">→</mo><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mi>x</mi><mo>+</mo><mi>t</mi><mi>σ</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x \to (1-t)x + tσ(x)</annotation></semantics></math>. ∎</li>
</ol>
<p>I imagine there is probably interest in programs automatically discovering such ambient isotopies and automatically proving the equivalence of certain links, or that certain links are separable. It would be interesting to know if neural networks can beat whatever the state of the art is there.</p>
<p><em>(Apparently determining if knots are trivial is NP. This doesn’t bode well for neural networks.)</em></p>
<p>The sort of links we’ve talked about so far don’t seem likely to turn up in real world data, but there are higher dimensional generalizations. It seems plausible such things could exist in real world data.</p>
<p>Links and knots are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-dimensional manifolds, but you need 4 dimensions to be able to untangle all of them. Similarly, one can need yet higher dimensional space to be able to unknot <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>-dimensional manifolds. All <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>-dimensional manifolds can be untangled in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2n+2</annotation></semantics></math> dimensions.<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a></p>
<p><em>(I know very little about knot theory and really need to learn more about what’s known regarding dimensionality and links. If we know a manifold can be embedded in n-dimensional space, instead of the dimensionality of the manifold, what limit do we have?)</em></p>
</section>
<section id="the-easy-way-out" class="level2">
<h2>The Easy Way Out</h2>
<p>The natural thing for a neural net to do, the very easy route, is to try and pull the manifolds apart naively and stretch the parts that are tangled as thin as possible. While this won’t be anywhere close to a genuine solution, it can achieve relatively low classification accuracy and be a tempting local minimum.</p>
<div class="bigcenterimgcontainer">
<img src="/assets/images/dl1/tangle.png" alt="" style="">
</div>
<div class="spaceafterimg">
</div>
<p>It would present itself as very high derivatives on the regions it is trying to stretch, and sharp near-discontinuities. We know these things happen.<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a> Contractive penalties, penalizing the derivatives of the layers at data points, are the natural way to fight this.<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a></p>
<p>Since these sort of local minima are absolutely useless from the perspective of trying to solve topological problems, topological problems may provide a nice motivation to explore fighting these issues.</p>
<p>On the other hand, if we only care about achieving good classification results, it seems like we might not care. If a tiny bit of the data manifold is snagged on another manifold, is that a problem for us? It seems like we should be able to get arbitrarily good classification results despite this issue.</p>
<p><em>(My intuition is that trying to cheat the problem like this is a bad idea: it’s hard to imagine that it won’t be a dead end.)</em></p>
</section>
<section id="better-layers-for-manipulating-manifolds" class="level2">
<h2>Better Layers for Manipulating Manifolds?</h2>
<p>The more I think about standard neural network layers – that is, with an affine transformation followed by a point-wise activation function – the more disenchanted I feel. It’s hard to imagine that these are really very good for manipulating manifolds.</p>
<p>Perhaps it might make sense to have a very different kind of layer that we use in composition with more traditional ones?</p>
<p>The thing that feels natural to me is to learn a vector field with the direction you want to shift the manifold:</p>
<div class="centerimgcontainer">
<img src="/assets/images/dl1/grid_vec.png" alt="" style="">
</div>
<div class="spaceafterimg">
</div>
<p>And then deform space based on it:</p>
<div class="centerimgcontainer">
<img src="/assets/images/dl1/grid_bubble.png" alt="" style="">
</div>
<div class="spaceafterimg">
</div>
<p>One could learn the vector field at fixed points (just take some fixed points from the training set to use as anchors) and interpolate in some manner. The vector field above is of the form:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mrow><msub><mi>v</mi><mn>0</mn></msub><msub><mi>f</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><msub><mi>v</mi><mn>1</mn></msub><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><mn>1</mn><mo>+</mo><msub><mi>f</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">F(x) = \frac{v_0f_0(x) + v_1f_1(x)}{1+f_0(x)+f_1(x)}</annotation></semantics></math></p>
<p>Where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>v</mi><mn>0</mn></msub><annotation encoding="application/x-tex">v_0</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>v</mi><mn>1</mn></msub><annotation encoding="application/x-tex">v_1</annotation></semantics></math> are vectors and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f_0(x)</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f_1(x)</annotation></semantics></math> are n-dimensional gaussians. This is inspired a bit by RBFs.</p>
</section>
<section id="k-nearest-neighbor-layers" class="level2">
<h2>K-Nearest Neighbor Layers</h2>
<p>I’ve also begun to think that linear separability may be a huge, and possibly unreasonable amount to demand of a neural network. In some ways, it feels like the natural feeling thing to do would be to use <a href="knn">k-nearest neighbors</a>. However, one clearly needs a good representation before k-NN can work well.</p>
<p>As a first experiment, I trained some ~1% test error MNIST networks (two layer conv nets, no dropout). I then dropped the final softmax layer and used the k-NN algorithm. I was able to consistently achieve a reduction in test error of 0.1-0.2%.</p>
<p>Still, this doesn’t quite feel like the right thing. The network is still trying to do linear classification, but since we use k-NN at test time, it’s able to recover a bit from mistakes it made.</p>
<p>k-NN is differentiable with respect to the representation it’s acting on, because of the 1/distance weighting. As such, we can train a network directly for k-NN classification. This can be thought of as a kind of “nearest neighbor” layer that acts as an alternative to softmax.</p>
<p>Clearly, we don’t want to feedforward our entire training set for each mini-batch. I think a nice approach is to classify each element of the mini-batch based on the classes of other elements of the mini-batch, giving each one a weight of 1/(distance from classification target).<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a></p>
<p>Sadly, this only gets down to 5-4% test error. Though I’ve put very little effort into playing with hyper-parameters. Using simpler networks gets worse results.</p>
<p>Still, I really aesthetically like this approach, because it seems like what we’re “asking” the network to do is much more reasonable. We want points of the same manifold to be closer than points of others. This should correspond to inflating the space between manifolds for different categories and contracting the individual manifolds. It feels kind of like simplification.</p>
</section>
<section id="conclusion" class="level2">
<h2>Conclusion</h2>
<p>Topological properties of data, such as links, may make it impossible to linearly separate classes using low-dimensional networks, regardless of depth. Even in cases where it is technically possible, such as spirals, it can be very challenging to do so.</p>
<p>To accurately classify data with neural networks, wide layers are sometimes necessary. Further, traditional neural network layers do not seem to be very good at representing important manipulations of manifolds. New layers, specifically motivated by the manifold perspective of machine learning, may be useful supplements.</p>
<p><em>(This is a developing research project. It’s posted as an experiment in doing research openly. I would be delighted to have your feedback on these ideas: you can comment inline or at the end. For typos, technical errors, or clarifications you would like to see added, you are encouraged to make a pull request <a href="https://github.com/colah/NN-Topology-Post">on github</a>.)</em></p>
</section>
<section id="acknowledgments" class="level2">
<h2>Acknowledgments</h2>
<p>Thank you to Yoshua Bengio, Michael Nielsen, Dario Amodei, Eliana Lorch, Jacob Steinhardt, and Tamsyn Waterhouse for their comments and encouragement.</p>
<div class="references">

</div>
</section>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>This seems to have really kicked off with <a href="http://www.cs.toronto.edu/~fritz/absps/imagenet.pdf">Krizhevsky <em>et al.</em>, (2012)</a>, who put together a lot of different pieces to achieve outstanding results. Since then there’s been a lot of other exciting work.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>These representations, hopefully, make the data “nicer” for the network to classify. There has been a lot of work exploring representations recently. Perhaps the most fascinating has been in Natural Language Processing: the representations we learn of words, called word embeddings, have interesting properties. See <a href="http://research.microsoft.com/pubs/189726/rvecs.pdf">Mikolov <em>et al.</em> (2013)</a>, <a href="http://www.iro.umontreal.ca/~lisa/pointeurs/turian-wordrepresentations-acl10.pdf">Turian <em>et al.</em> (2010)</a>, and, <a href="http://www.socher.org/">Richard Socher’s work</a>. To give you a quick flavor, there is a <a href="http://metaoptimize.s3.amazonaws.com/cw-embeddings-ACL2010/embeddings-mostcommon.EMBEDDING_SIZE=50.png">very nice visualization</a> associated with the Turian paper.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>A lot of the natural transformations you might want to perform on an image, like translating or scaling an object in it, or changing the lighting, would form continuous curves in image space if you performed them continuously.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p><a href="http://comptop.stanford.edu/u/preprints/mumford.pdf">Carlsson <em>et al.</em></a> found that local patches of images form a klein bottle.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>This result is mentioned in <a href="http://en.wikipedia.org/wiki/Whitney_embedding_theorem#Isotopy_versions">Wikipedia’s subsection on Isotopy versions</a>.<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>See <a href="http://cs.nyu.edu/~zaremba/docs/understanding.pdf">Szegedy <em>et al.</em></a>, where they are able to construct take data samples and find slight modifications that cause some of the best image classification neural networks to misclasify the data. It’s quite troubling.<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>Contractive penalties were introduced in contractive autoencoders. See <a href="http://www.iro.umontreal.ca/~lisa/pointeurs/ICML2011_explicit_invariance.pdf">Rifai <em>et al.</em> (2011)</a>.<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>I used a slightly less elegant, but roughly equivalent algorithm because it was more practical to implement in Theano: feedforward two different batches at the same time, and classify them based on each other.<a href="#fnref8">↩</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>Chrome + GoAgent + GoGoTester 完美翻墙教程， 让我们越过那片海</title>
    <link href="https://xinitrc.de/blog/2015/06/15/goagent.html" />
    <id>https://xinitrc.de/blog/2015/06/15/goagent.html</id>
    <published>2015-06-15T00:00:00Z</published>
    <updated>2015-06-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Chrome + Goagent + GoGoTester, cross the GFW and see the world.</p>
<!--more-->
<p>update: 近日 GoAgent 在 Github 上的 repo 已经被勒令删除，参考本文翻墙时请下载百度网盘中的 GoAgent。</p>
<section id="前言" class="level2">
<h2>### 前言</h2>
<p>这篇博文主要讲述<strong>使用 Chrome + GoAgent + GoGoTester 完美翻墙</strong>，大多数的工作仍是搬砖，因为现在大多的翻墙教程已经讲的足够详细。<strong>但是，现在大部分教程都忽略了一个特别重要的事实！未翻墙的时候是无法注册 GAE (Google App Engine)的</strong>。因此，所有后续的步骤都难以进行下去。针对这个问题，我们提出如下的解决办法。 * 下载使用最新畅游版 Chrome ，畅游版 Chrome 已经默认配置好了 goagent ，可以直接使用。<strong>但是，问题来了。。现在很多畅游版 Chrome 由于并没有及时更新的原因，可能下载之后还是翻不过那片墙。</strong> * 此种方法针对<strong>高富帅</strong>。百度一下 VPN ，购买一定期限的 VPN 账号，挂载到<strong>大陆以外的 IP 地址</strong>，即可实现翻墙。挂载 VPN 的过程不同 VPN 代理商有不同的方法，按照他们的方法配置即可。 * 此种方法针对<strong>纯屌丝</strong>。之所以称之为纯屌丝，是因为正常人谁能干出这事来。。同样基于 VPN ，因为在购买 VPN 账号之前，通常会有 10 - 60 分钟不等的试用时间，咳咳，把握好这个时间！<strong>试用期间，你是可以越过墙的！！</strong>一个账号时间不够的话，就多注册几个试用账号。。其他的自己把握吧，我是真的没脸再讲下去了！ * 找一个身边可以翻墙出去的人来为你进行下面操作。</p>
<p><strong>Google App Engine 已经改版，创建应用（create application）的过程已经完全不同于以前的教程，请参考下文。</strong></p>
</section>
<section id="goagent翻墙原理" class="level2">
<h2>### GoAgent翻墙原理</h2>
<p>实际操作前，先讲述一下 GoAgent 翻墙的原理。首先通过一张图片来看一下我们伟大的 GFW（Great Firewall of China）的赫赫战功。 <img src="/assets/images/goagent/ip.jpg" alt="" /></p>
<p>这是全球访问量前30的网站，带有红线的表明被墙掉了，很明显，半壁江山已经沦陷，喔，据说最近全球最大的同性交友网站 <strong>Github</strong> 和 自由百科全书中文 <strong>Wikipedia</strong> 也相继进小黑屋了，这充分说明我国的技术水平还是可以的。</p>
<p>言归正传，那么 <strong>GoAgent</strong> 是什么呢？<strong>GoAgent</strong> 是使用跨平台语言Python开发的代理软件，利用 <strong>Google App Engine</strong> 的服务器充当代理，帮助用户浏览被封锁的内容（<a href="https://zh.wikipedia.org/wiki/GoAgent">转自wikipedia</a>）。<strong>GoAgent</strong> 的运行原理与其他代理工具基本相同，使用特定的中转服务器完成数据传输。它使用 <strong>Google App Engine</strong> 的服务器作为中传，将数据包后发送至 Google 服务器，再由 Google 服务器转发至目的服务器，接收数据时方法也类似。</p>
<p>这里又产生了一个<strong>代理服务器</strong>的概念。<strong>代理（Proxy）</strong>，也称网络代理，是一种特殊的网络服务，允许一个网络终端（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。提供代理服务的电脑系统或其它类型的网络终端称为<strong>代理服务器（Proxy Server）</strong>。如果你还没有理解，没有关系，可以用一个词生动形象的来描述代理——<strong>中介</strong>！</p>
<p>当我们访问上述被墙掉的网站时，我们不再访问网站的特定服务器（<strong>因为已经被墙掉了</strong>），转而我们访问 Google 的<strong>代理服务器（中介）</strong>，由代理服务器去访问我们要访问的网站，因为代理服务器并没有被墙掉，可以访问指定网站，然后指定网站返回数据给代理服务器，代理服务器再将数据返回给我们，以此来达到翻墙的目的。</p>
</section>
<section id="配置goagent" class="level2">
<h2>### 配置GoAgent</h2>
<p>已经了解了原理，那么下面我们来具体的走一遍流程。下文部分参考自<a href="http://www.zhiyanblog.com/goagent-chrome-switchyomega-proxy-2015-latest.html">Goagent+Chrome+SwitchyOmega使用教程最新版(2015.1)</a>。</p>
<p>这里我假设此时你不论通过上面所提出的三种途径中的哪种途径，短暂的获得了可以访问墙外网站的机会。</p>
<ul>
<li><p>首先，访问 <a href="https://appengine.google.com">Google App 中心</a> 申请注册 Google App Engine 账号。建议直接注册 Gmail 账户，一个账户畅享 Google 所有服务。如下所示，点击创建账户，然后填入相应信息完成创建。 <img src="/assets/images/goagent/createAccount.png" alt="" /><img src="/assets/images/goagent/perinfo.png" alt="" /></p></li>
<li><p>账户创建完成后会自动登录。点击返回 <strong>Google Developers Console</strong>，进入创建应用界面，点击 <strong>Create Application</strong>。 <img src="/assets/images/goagent/return.png" alt="" /><img src="/assets/images/goagent/createapp.png" alt="" /></p></li>
<li><p>刚刚发现，<strong>Google App Engine</strong> 改版了，注册 Application ID 的方法也不再像以前一样，按照上述步骤可进入到如下界面。 <img src="/assets/images/goagent/appid.png" alt="" /><img src="/assets/images/goagent/newproject.png" alt="" /></p></li>
<li><p>点击建立专案，然后输入专案名称，点击建立即可。<strong>填入专案名称后生成的专案 ID 即为我们的 application id </strong>。注，由于我默认的地区是中国，所以字体是繁体（国内简体也被 Google 屏蔽了），不适应繁体也可以换为英语。此时返回 <a href="https://appengine.google.com/">Google app engine</a> 可以看到我们刚刚所创建的 Application 。 <img src="/assets/images/goagent/showapplication.png" alt="" /></p></li>
<li><p>下载 GoAgent，GoAgent 发布在 Github 上，如果可以登录 Github 话，可以直接访问 <a href="https://github.com/goagent/goagent">Github GoAgent</a>。下载方法可以打开 git bash，进入工作目录，然后输入以下命令。</p>
<pre><code>$ git clone https://github.com/goagent/goagent.git</code></pre>
<p>也可以直接下载 ZIP 文件解压。<strong>若 Github 无法直接访问</strong>，请下载<a href="http://pan.baidu.com/s/1kTzjryJ">百度网盘 GoAgent</a>。</p></li>
</ul>
<blockquote>
<p><strong>这里插一句吐槽百度网盘的话</strong>，昨天开始使用百度云网盘，先是 Chrome 浏览器上传文件持续失败，google 原因有的说因为上传速度过快导致，更换 Firefox 浏览器解决如上问题。刚刚上传 GoAgent 文件至网盘，分享链接持续失效，google 原因竟然是有些文件名涉及到关键字的问题，真心无奈。更换文件名 GA ，再次分享成功。用户体验太差了，失败也不给个原因。</p>
</blockquote>
<ul>
<li><p>使用文本编辑器（notepad++ 或者 sublime）打开<code>goagent-3.0/local/proxy.ini</code>文件，找到如下代码，修改其中 <code>appid =</code>刚刚我们所申请的 <code>application id</code>。</p>
<pre><code>[listen]
ip = 127.0.0.1
port = 8087
username =
password =
visible = 0
debuginfo = 0

[gae]
enable = 1
appid = goagent</code></pre></li>
<li><p>上传相应信息，请确保你现在的网络环境处于<strong>暂时可以越过墙</strong>的状态，否则无法连接到 google engine 服务器。Win7 系统下以管理员身份运行<code>goagent-3.0/server/upload.bat</code>文件，会出现以下内容。</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">APPID</span>:                             // 这个位置请输入我们刚刚所注册的专案 ID，即application id。可从[My application](https://appengine.google.com/)中查看。
<span class="kw">Application</span>：aaronyeemail-976      // 这个位置会自动出现我们上一行所填入的 ID。
<span class="kw">Host</span>: appengine.google.com         // 自动出现
<span class="kw">Rolling</span> back the update
<span class="kw">Email</span>:                             // 此处需要填入你的 google 账户，即 Gmail 账户
<span class="kw">Password</span> for ... :                 // 此处填入 Gmail 账户的密码</code></pre></div></li>
</ul>
<p><strong>注意，新版本的 Application界面我并没有找到开启两步验证的地方，所以上面的密码我们填入的是 Gmail 账户的密码。</strong></p>
<p><strong>输入密码后。会自动出现一系列内容，结尾处你会看到上传出现了错误，<code>attribute error: can't set attribute</code>，这是正常的现象，</strong>此时打开你的邮件，Gmail 账户或者我们注册 Gmail 时候填入的辅助邮箱**，会收到一封安全性的警告文件。 <img src="/assets/images/goagent/warn.png" alt="" /></p>
<p>进入<strong>如果这是您本人所为</strong>下面的网址中，将<strong>不够安全的应用的访问权限更改为启用</strong>。 <img src="/assets/images/goagent/change.png" alt="" /></p>
<ul>
<li><p>重复上一步上传的步骤，Win7 系统下以管理员身份运行<code>goagent-3.0/server/upload.bat</code>文件，输入相应内容即可完成上传。可能需要尝试几次，我在第三次上传成功。 <img src="/assets/images/goagent/success.jpg" alt="" /></p></li>
<li><p>Win7下以管理员身份运行<code>goagent-3.0/local/goagent.exe</code>，自动导入证书，<strong>GoAgent 配置完毕</strong>。（现存最新版的 goagent 文件夹中已经不含 <code>CA.crt</code>文件，已经集成到了自动安装证书）</p></li>
</ul>
</section>
<section id="配置chrome" class="level2">
<h2>### 配置Chrome</h2>
<p>本文以 Chrome 浏览器为例，若想切换为其他的浏览器，可以参考<a href="https://github.com/goagent/goagent/blob/wiki/InstallGuide.md">goagent 官方 installGuide</a>。<strong>但 GoAgent 的配置与上文一致！</strong></p>
<ul>
<li><p>首先，下载 Chrome 下扩展插件 <a href="https://github.com/FelisCatus/SwitchyOmega/releases">SwitchyOmega.crx</a>，若无法打开，请前往<a href="http://pan.baidu.com/s/1pJsV96V">百度网盘 SwitchyOmege.crx</a>。</p></li>
<li><p>打开 Chrome 浏览器，地址栏输入<code>Chrome://extensions/</code>后回车，打开扩展应用管理页，将刚才下载的<code>SwitchyOmega.crx</code>拖曳到当前页面下，点击确定即可完成安装。 <img src="/assets/images/goagent/add.png" alt="" /></p></li>
<li><p>点击 Chrome 浏览器右上角出现的 SwitchyOmega 的图标，点击选项，在弹出页面的左侧栏中选择<strong>导入/导出，从备份文件恢复，打开<code>goagent-3.0/local/SwitchyOptions.bak</code></strong>，导入成功后， 在<strong>扩展设置页点击自动切换，并点击立即更新情景模式，然后点击 SwitchyOmega 的图标选择自动切换</strong>，完成 Chrome 配置。 <img src="/assets/images/goagent/input.png" alt="" /></p></li>
</ul>
<p>至此，我们已经完成了近乎全部的配置过程，想必你的 <strong>VPN 试用时间</strong>已经差不多到时了，那么任性的退掉 VPN，尝试下我们自己翻过去的墙吧！记得，每次想翻墙的时候，要先以管理员身份运行<code>goagent-3.0/local/goagent.exe</code>，然后打开 Chrome 浏览器即可畅通无阻。</p>
</section>
<section id="gogotester复活-goagent" class="level2">
<h2>### GoGoTester，复活 GoAgent</h2>
<p>翻墙了一段时间之后，我们可能会很悲剧的发现，google 又不能正常的使用了，<strong>打开 GoAgent 会发现大片的黄色 warning 和红色 error</strong>，那么此时，你的 GoAgent 已经瘫痪了，陷入了一种假死的状态。什么？？废了这么大力搭配好的环境难道就这么报废了吗？别急。<strong>GoGo Tester 来帮助你复活 GoAgent</strong>。 &gt; 首先说明一下 GoGo Tester 的原理，goagent 的工作方法，第一步是从自己的机器，通过运行于本机的 proxy 程序，连接到世界各地的某台外网 google 服务器。从 GoGo Tester 软件得知，有100万个这样的IP地址，对应多少服务器不太清楚，但目前来说，显然墙还没有把这些机器全部封掉。这样的话，GoGo tester 扫描到能工作的服务器后，配置到 goagent 中，就可以正常使用 goagent了。</p>
<ul>
<li><p>首先，<a href="https://code.google.com/p/gogo-tester/">下载 GoGo Tester</a>（打不开的话请选择<a href="http://pan.baidu.com/s/19Bgho">百度网盘 GoGoTester</a>，其中的两个文件为不同版本，either is okay，普遍反映老版本更好用一点，即<code>GoGo.exe</code>），若程序无法运行，请先安装<a href="http://www.microsoft.com/zh-cn/download/details.aspx?id=17718">.NET Frameworks 4.0</a>。</p></li>
<li><p>打开GoGo Tester，点击随机测试，填入数量开始测试，会得到一系列 IP 地址。<strong>右键选择导出，全部 IP 到剪贴板</strong>即可复制下来可用的 IP 地址。 <img src="/assets/images/goagent/gogo.png" alt="" /></p></li>
<li><p>使用文本编辑器打开<code>goagent-3.0/local/proxy.ini</code>文件，在其中找到如下代码。</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">[<span class="kw">iplist</span>]
<span class="kw">google_cn</span> = www.google.cn<span class="kw">|www.g.cn</span>
<span class="kw">google_hk</span> = www.google.com<span class="kw">|mail.google.com|www.google.com.hk|www.google.com.tw|www.l.google.com|www2.l.google.com|www3.l.google.com|www4.l.google.com|www5.l.google.com|mail.l.google.com|googleapis.l.google.com|googlecode.l.googleusercontent.com|maps.l.google.com|code.l.google.com|cert-test.sandbox.google.com</span>
<span class="kw">google_talk</span> = talk.google.com<span class="kw">|talk.l.google.com|talkx.l.google.com</span></code></pre></div></li>
</ul>
<p>在<code>google_cn</code>和<code>google_hk</code>的等号后面分别加入我们刚刚测试得到的<strong>已经复制到剪贴版的 IP 地址</strong>（默认复制后剪贴板各个 IP 地址间已经包含<code>|</code>符号，只需在粘贴处添加一个<code>|</code>与原内容隔开即可）。</p>
<ul>
<li>保存设置，重新启动<code>goagent-3.0/local/goagent.exe</code>，okay，GoAgent 已经完美复活！</li>
</ul>
</section>
<section id="后记" class="level2">
<h2>### 后记</h2>
<p>当你本机的 GoAgent 配置好后，只需将<code>goagent</code>的整个文件夹拷贝到其他电脑上（不需重新配置 GoAgent），并再配置一次 Chrome 浏览器，即可继续享受翻墙服务。所以这是一件<strong>牺牲你一个，幸福千万家</strong>的事（木有这么夸张，拷贝的话是共享同一个app ID，每个 application 每天限制 1G 流量）。</p>
<p>虽然教程看起来比较复杂，但真正熟练之后操作起来也就是十几分钟的事。虽然同样可以花几十大洋换几月平安，但是，自己翻出去这种<strong>成就感</strong>是无法比拟的。</p>
<p><strong>So let’s move，行动起来吧！</strong></p>
<div class="references">

</div>
</section>]]></summary>
</entry>
<entry>
    <title>hexo 博客推广——世界那么大，让人看看我们</title>
    <link href="https://xinitrc.de/blog/2015/06/14/blog-open.html" />
    <id>https://xinitrc.de/blog/2015/06/14/blog-open.html</id>
    <published>2015-06-14T00:00:00Z</published>
    <updated>2015-06-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>How to make your blog searched by Google or Baidu ?</p>
<!--more-->
<figure>
<img src="/assets/images/transmission/share2.png" alt="" />
</figure>
<section id="前言" class="level2">
<h2>### 前言</h2>
<p>兴致勃勃的搞了三天 blog ，然后发现在搜索引擎中无法检索，即使直接在搜索引擎中输入域名也会提示网址不存在，只能通过直接在地址栏输入域名才可以访问。（第一张图片部分不属实，因为博文发布时我已经测试好搜索引擎能够检索到我的 blog，前后大概不到半个小时吧。 Google 的效率不得不赞，百度的检索图片属实。）<strong>我们写 blog 的很大部分原因也是为了和他人分享，那么应该怎样才能让搜索引擎检索到我们的博客呢？</strong> <img src="/assets/images/transmission/googlenot.png" alt="" /> <img src="/assets/images/transmission/not.png" alt="" /></p>
<p>本博文整合自<a href="http://zhaofei.tk/2014/12/21/add_blog_to_google/">博客推广——提交搜索引擎</a>，<a href="http://fionat.github.io/blog/2013/10/23/sitemap/">｜Hexo优化｜如何向google提交sitemap</a>，另外来自个人实践。</p>
</section>
<section id="配置" class="level2">
<h2>### 配置</h2>
<p>我们忽略的最重要的一个事实是<strong>当我们的博客建立好后，搜索引擎并不知道这个事实，所以需要我们去通知它们。</strong>搜索引擎提供了<code>添加网站</code>入口 * <a href="https://www.google.com/webmasters/tools/home?hl=zh-CN">Google 搜索提交入口</a> * <a href="http://www.baidu.com/search/url_submit.htm">Baidu 搜索提交入口</a> Google 搜索已确认有效，Baidu 暂时还不知道是否成功，所以此处以 Google 为例。</p>
<ul>
<li><p>首先，进入 <a href="https://www.google.com/webmasters/tools/home?hl=zh-CN">Google 搜索提交入口</a>，登陆 Gmail 账户后出现如下界面，在添加资源栏中输入个人博客地址，如<code>http://aaronyee.github.io</code>，点击添加资源。 <img src="/assets/images/transmission/console.png" alt="" /></p></li>
<li><p>验证对网站的所有权，按照下图所示步骤，下载指定的 html 文件，将其放在<code>blog/public</code>文件夹下（blog指博客根目录），然后在 git bash 下执行命令<code>hexo d</code>将其部署到 github 端即可， 关于部署的问题有不明白可以参考<a href="http://aaronyee.github.io/2015/06/13/abouthexo/">关于Hexo的那些事</a>或<a href="http://aaronyee.github.io/2015/06/13/hexogithub/">Github page 搭配 Hexo 搭建独立博客</a>。部署成功后继续后续步骤即可完成验证。 <img src="/assets/images/transmission/check.png" alt="" /> <img src="/assets/images/transmission/success.png" alt="" /></p></li>
<li><p>此时，我们已经将我们博客的存在告知了 Google 搜索引擎，经过一段时间后便可以在搜索引擎上通过指定的内容检测到我们的博客。那么，<strong>有没有什么办法能够提高被检测到的概率呢？</strong>官方的回答如下图所示。 <img src="/assets/images/transmission/increase.png" alt="" /></p>
<p>对于前两项，如果是自己独立购买的域名可以进行相应的设置，如果和我一样是采用 Github page 分配的二级域名，那么我们配置一下第三，国家和地区。如下图所示，在 <code>Search Console</code>中选择<strong>搜索流量——国际定位——国家/地区</strong>，设置即可。 <img src="/assets/images/transmission/locate.png" alt="" /></p></li>
<li><p>上面提高被访问概率的第五项可以看到<strong>提交站点地图文件</strong>，那么怎么提交站点地图文件呢？此时我们需要自动生成<code>sitemap.xml</code>文件。使用 Git bash 进入到 blog 的根目录，安装插件（<code>node_modules</code>中存在则无需再次安装）。</p>
<pre><code>$ npm install hexo-generator-sitemap                </code></pre>
<p>打开 blog 根目录下的配置文件<code>_config.yml</code>，需配置两项，首先，找到<code>url</code>项，将 url 修改为个人的 blog 地址。</p>
<pre><code># URL
## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;
url: http://aaronyee.github.io                        // 这里替换为个人的 blog 地址</code></pre>
<p>然后，找到<code>sitemap</code>选项，修改其 <code>path</code>属性的值（没有则自己添加）。 #sitemap sitemap: path: sitemap.xml</p>
<p>在 Git bash 中输入命令将 blog 部署到服务器端。 $ hexo g $ hexo d 打开浏览器，在地址栏中输入<code>http://aaronyee.github.io/sitemap</code>，将其中的地址替换为个人blog地址，若浏览器弹出以下界面，证明 sitemap 生成成功。</p>
<figure>
<img src="/assets/images/transmission/xml.png" alt="" />
</figure>
<p>注意看其中的<code>&lt;loc&gt;http://aaronyee.github.io/2015/06/14/goagent/&lt;/loc&gt;</code>，若显示的是<code>&lt;loc&gt;http://yoursite/2015/06/14/goagent/&lt;/loc&gt;</code>，则证明未修改<code>_config.yml</code>的 <strong>URL 项</strong>。</p>
<p>再次在浏览器中打开 Google Search Console 界面，选择<strong>抓取——站点地图——添加/测试站点地图</strong>。 <img src="/assets/images/transmission/addsite.png" alt="" /></p>
<p>在添加/测试站点地图中填入<code>sitemap</code>，先测试站点地图查看是否有误，若无误点击<code>提交 Sitemap</code>即可。 <img src="/assets/images/transmission/input.png" alt="" /></p></li>
<li><p>经过个人测试，发现手动对个人 blog 进行抓取，似乎可以加快被搜索引擎索引的速度。找到** Search Console —— 抓取—— Google 抓取方式<strong>，将个人 blog 的相关页面填入其中，分别抓取即可，呈现页也可显示出</strong> 网站的访问者看到的网页样貌**。 <img src="/assets/images/transmission/hold.png" alt="" /></p></li>
</ul>
<section id="后记" class="level3">
<h3>后记</h3>
<p>本篇博文主要讲述<strong>如何使个人站点被搜索引擎检索以及如何提高被检索概率</strong>，亲证 Google 搜索引擎有效，暂时未知 baidu 搜索引擎是否有效，但在向百度搜索引擎中加入 sitemap 时不断提示出错，原因未知。</p>
<p>如果能在搜索的结果中排名靠前呢？很显然，<strong>质量才是王道</strong>。只有好的博文才能吸引更高的访问量，被更多人链接，从而获得更高的搜索排名。</p>
<p><strong>Just do it ， 从点滴做起！</strong></p>
<div class="references">

</div>
</section>
</section>]]></summary>
</entry>
<entry>
    <title>关于 Hexo ，也就是那些事儿</title>
    <link href="https://xinitrc.de/blog/2015/06/13/abouthexo.html" />
    <id>https://xinitrc.de/blog/2015/06/13/abouthexo.html</id>
    <published>2015-06-13T00:00:00Z</published>
    <updated>2015-06-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>What is Hexo ? Why Hexo ? How to use Hexo ?</p>
<!--more-->
<figure>
<img src="/assets/images/abouthexo/hexo.png" alt="" />
</figure>
<section id="前言" class="level2">
<h2>### 前言</h2>
<p>这篇博文主要介绍用hexo写blog中所涉及到的一些内容，内容参考自<a href="http://hexo.io/zh-cn/docs/">hexo官方文档</a>和<a href="http://ijiaober.github.io/categories/hexo/">ijiaober的Hexo使用攻略系列</a>。</p>
</section>
<section id="hexo简介" class="level2">
<h2>### Hexo简介</h2>
<ul>
<li><p><strong>Q. 什么是Hexo？</strong> &gt; 快速、简洁且高效的博客框架，made by <a href="http://tommy-chen.com/">Tommy Chen</a>。(Tommy Chen的个人主页太炫酷了。)</p></li>
<li><strong>Q. Hexo的优势？</strong> &gt; * 超快速度，Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。</li>
<li>支持Markdown，Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。</li>
<li>一键部署，只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。</li>
<li>丰富的插件，Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。</li>
<li><p>简单的操作，几条命令即可完成blog框架的搭建。 $ npm install hexo-cli -g $ hexo init blog $ cd blog $ npm install $ hexo server</p></li>
</ul>
</section>
<section id="hexo安装" class="level2">
<h2>### Hexo安装</h2>
<p>安装Hexo很简单，需要在安装前确认已经安装下列应用程序： * <a href="https://nodejs.org/">Node.js</a> * <a href="http://git-scm.com/">Git</a> 接下来只需要在Git bash中使用npm即可完成Hexo的安装。 $ npm install -g hexo-cli 若Git bash中提示 <strong>npm command not found</strong>，请检查 <strong>Node.js</strong> 的配置信息，是否将 <strong>Node.js</strong> 的路径加入到环境变量中（建议安装 <strong>Node.js</strong> 时不要修改默认安装路径）。若确认无误仍出现上述错误，请打开 <strong>windows command</strong> 命令行，进入 <strong>node.js</strong> 安装路径下尝试安装。<br />
 C:Files_modules&gt; npm install -g hexo-cli 测试，若输入命令后出现类似下述内容后，则证明安装成功。 $ hexo version hexo: 3.1.1 os: Windows_NT http_parser: 2.3 node: 0.12.4 v8: 3.28.71.19</p>
</section>
<section id="hexo初探" class="level2">
<h2>### Hexo初探</h2>
<p>Hexo安装成功后，我们首先来试用一下。首先创建一个我们想要保存blog信息的文件夹，anyway，anywhere。然后，打开 git bash，执行以下命令。</p>
<pre><code>$ hexo init &lt;folder&gt;
$ cd &lt;folder&gt;
$ npm install</code></pre>
<p>其中的 <strong>&lt;folder&gt;</strong> 为我们刚刚所建立的文件夹名称，注意存放位置的问题，此处需使用<strong>文件夹的绝对路径</strong>。也可以先用 git bash 进入到目录文件夹，再执行初始化操作。观察我们刚刚所建立的文件夹，会发现其中多出了如下的文件。</p>
<pre><code>.
├── node_modules
├── _config.yml        
├── package.json       
├── scaffolds          
├── scripts            
├── source             
|   ├── _drafts
|   └── _posts
└── themes       </code></pre>
<p>关于各个文件夹，我们稍后再详细介绍。接下来，我们使用 Hexo 预带的内容生成第一个静态页面。</p>
<pre><code>$ hexo generate    // hexo g is also okay    </code></pre>
<p>观察 blog 文件夹下，会发现多出了 public 文件夹，这便是我们所产生的静态网页文件所存放的位置。</p>
<p>然后开启 local 本地端hexo服务器。</p>
<pre><code>$ npm install hexo-server --save
$ hexo server     // hexo s is also okay</code></pre>
<p>打开浏览器，地址栏输入 <code>http://localhost:4000</code> 即可观察到hexo预带的网页展示。</p>
<p>关于如何本地的网页部署到Github端，请参考<a href="http://aaronyee.github.io/2015/06/12/hello-world/">Github page 搭配 Hexo 搭建独立博客</a>。</p>
</section>
<section id="hexo管理与配置" class="level2">
<h2>### Hexo管理与配置</h2>
<p>谈到 Hexo 的管理，我们首先来看一下 blog 根目录下每个文件夹的作用。</p>
<ul>
<li><p><code>node_modules</code>，这个文件夹中存放的主要是 hexo 的相关插件，我们通过命令 <code>npm install</code> 所安装的插件包便存放在这个文件夹中，除了默认安装的插件外，如缺少插件可采用如下命令的格式来安装。</p>
<pre><code>$ npm install hexo-generator-index --save
$ npm install hexo-generator-archive --save
$ npm install hexo-generator-category --save
$ npm install hexo-generator-tag --save
$ npm install hexo-server --save
$ npm install hexo-deployer-git --save
$ npm install hexo-deployer-heroku --save
$ npm install hexo-deployer-rsync --save
$ npm install hexo-deployer-openshift --save
$ npm install hexo-renderer-marked@0.2 --save
$ npm install hexo-renderer-stylus@0.2 --save
$ npm install hexo-generator-feed@1 --save
$ npm install hexo-generator-sitemap@1 --save</code></pre></li>
<li><p><code>public</code>，这个文件夹中存放的是我们使用hexo框架+Markdown语法写出的blog经过动态编译后形成的静态网页文件，包括 css 与 js 的内容。若想将本地的 blog 部署到服务器端（如 Github page ），只需将<code>public</code>文件夹中的内容上传到服务器端即可。</p></li>
<li><p><code>scaffolds</code>，这个文件夹中存放的是创建新的 blog 时的模板信息，所以如果有固定的写作样式等等，可以通过配置这个文件夹中的相应文件达到目的。</p>
<pre><code>title: { title }</code></pre>
<p>date: { date } categories: tags: — 如我的<code>scaffolds/post.md</code>中的内容如下所示，那么每次我<code>hexo new {title}</code>写新的 blog 的时候，上述内容便会自动出现在新的 blog 的开头。</p></li>
<li><p><code>source</code>，这个文件夹中是我们本地的资源文件夹，例如我们通过<code>hexo new {title}</code>生成的 blog 便会存在于 <code>source/_posts</code>文件夹中。</p></li>
<li><p><code>themes</code>，这个文件夹中存放的是我们搭配 blog 框架时候所使用的主题信息，<code>hexo 3.1.1</code>的默认主题是 <code>landscape</code>。</p></li>
<li><p><code>_config.yml</code>，这个文件是我们整个 blog 框架的配置信息。下面贴出个人的配置文件并附上注释信息，大家可根据自己的需要进行修改。 # Hexo Configuration ## Docs: http://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/</p>
<pre><code># Site
title: Aaron-Yee Blog                       # // 网站标题
subtitle: 专注 &amp; 沉淀                       # // 网站副标题
description:                                # // 网站描述
author: Aaron Yee                           # // 作者名字
language: zh-CN                             # // 网站使用的语言
timezone:

# URL
## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;
url: http://yoursite.com
root: /
about_dir: about
tag_dir: tags
category_dir: categories
permalink: :year/:month/:day/:title/
permalink_defaults:

# Directory                                 // 目录
source_dir: source                          # // 资源文件夹，用来存放内容
public_dir: public                          # // 公共文件夹，用于存放生成的站点文件
tag_dir: tags                               # // 标签文件夹
archive_dir: archives                       # // 归档文件夹
category_dir: categories                    # // 分类文件夹
code_dir: downloads/code                    # // include code 文件夹
i18n_dir: :lang                             # // 国际化(i18n)文件夹
skip_render:                                # // 跳过指定文件的渲染

# Writing                                   // 设置hexo new 时候的相关配置
new_post_name: :title.md                    # // 新文章文件名称 # File name of new posts                
default_layout: post                        # // 预设布局
titlecase: false                            # // 把标题转换为title case # Transform title into titlecase
external_link: true                         # // 在新标签中打开链接 # Open external links in new tab
filename_case: 0                            # // 把文件名称转换为(1)小写或(2)大写
render_drafts: false                        # // 显示草稿
post_asset_folder: false                    # // 启动Asset文件夹
relative_link: false                        # // 把链接改为与根目录的相对位置
future: true                                # // 显示未来的文章
highlight:                                  # // 代码块设置
  enable: true
  line_number: true
  auto_detect: true
  tab_replace:

# Category &amp; Tag                            // 分类 &amp; 标签
default_category: uncategorized
category_map:
        机器学习: Machine Learning
        深度学习: Deep Learning
        技术杂谈: tittle-tattle
tag_map:

# Date / Time format
## Hexo uses Moment.js to parse and display date
## You can customize the date format as defined in
## http://momentjs.com/docs/#/displaying/format/
date_format: YYYY-MM-DD
time_format: HH:mm:ss

# Pagination
## Set per_page to 0 to disable pagination
per_page: 10
pagination_dir: page

# Extensions
## Plugins: http://hexo.io/plugins/
## Themes: http://hexo.io/themes/
theme: jacman                              # // 主题名称

# Deployment
## Docs: http://hexo.io/docs/deployment.html
deploy:
  type: git
  repo: https://github.com/AaronYee/AaronYee.github.io.git
  branch: master</code></pre></li>
</ul>
<p>关于上述配置信息如果还有不明白的地方，请参考<a href="http://hexo.io/zh-cn/docs/configuration.html">Hexo 的官方文档</a>。</p>
</section>
<section id="hexo命令" class="level2">
<h2>### Hexo命令</h2>
<p>Hexo 的命令都是在类似于 Git bash 这样的终端中来输入的。</p>
<ul>
<li><pre><code>新建一个网站框架（即整个 blog）。如果没有设置 folder ，Hexo 默认是在当前的工作目录下建立网站框架。		
	$ hexo init [folder]</code></pre></li>
<li><pre><code>新建一篇 blog 。如果没有设置 layout 的话，默认使用 **_config.yml** 中的 **default_layout** 参数代替。如果标题包含空格的话，请使用引号括起来。(`&lt; &gt;` 符号不必打出。)

	$ hexo new [layout] &lt; title &gt;</code></pre></li>
<li><pre><code>生成静态文件。

	$ hexo generate 
	$ hexo generate --deploy       // 表示文件生成后立即部署到服务器端.
	$ hexo generate --watch        // 监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。</code></pre></li>
<li><p>发表草稿。</p>
<pre><code>	$ hexo publish [layout] &lt; filename &gt;</code></pre></li>
<li><pre><code>启动本地端服务器。
	$ hexo server
	$ hexo server -p 5000          // 将端口更改为5000
	$ hexo server -s               // 静态模式服务器只处理 public 文件夹内的文件，而不会处理文件变动，执行时应该先自行执行 hexo generate。
	$ hexo server -i 192.168.1.1   // 服务器默认运行在 `0.0.0.0`，可以覆盖默认的 IP 设置。</code></pre></li>
<li><p>部署网站，只需一条命令就能将网站部署到服务器上。 $ hexo deploy 但在开始之前，需要安装<code>hexo-deployer-git</code>插件。 $ npm install hexo-deployer-git –save 修改<code>_config.yml</code>的参数设置。以部署到 Github page 为例，用文本编辑器打开<code>_config.yml</code>，找到 deploy 选项，修改参数。 # Deployment ## Docs: http://hexo.io/docs/deployment.html deploy: type: git repo: &lt; repository url &gt; // repository url 替换为个人的Github page地址 branch: master // 分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。</p>
部署到其他地方的话，请参考<a href="http://hexo.io/zh-cn/docs/deployment.html">官方文档</a>。</li>
<li><pre><code>从其他系统迁移到Hexo。具体内容请参考[hexo迁移](http://hexo.io/zh-cn/docs/migration.html)。
	$ hexo migrate &lt; type &gt;</code></pre></li>
</ul>
<p>更多命令请参考<a href="http://hexo.io/zh-cn/docs/commands.html">hexo官方文档——命令</a>。</p>
<p>那么，我们使用 Hexo 写博文的整个流程大概是这样的。</p>
<pre><code>		$ mkdir &quot;blog folder&quot;
		$ cd &quot;blog folder&quot;
		$ hexo init
		$ npm install
		$ hexo new &quot;blog title&quot;
		$ echo &quot; &quot; &gt; &quot;blog title&quot;      // 双引号中的内容表示 blog的内容，此处推荐使用文本编辑器编辑 hexo new 命令生成的 &quot;blog title&quot;.md 文件。
		$ hexo generate
		$ hexo server                  // 在本地服务器端调试，待确认无误后，上传到Github page服务器。
		$ hexo deploy</code></pre>
</section>
<section id="玩转hexo" class="level2">
<h2>### 玩转Hexo</h2>
<p>此处我假设我们都已经按照上文搭建好了我们的框架，但是打开主页我们会发现很多地方我们不满意，那么应该怎么修改呢？实际上，<strong>每个主题有各自不同的修改方法</strong>，此处以 Hexo 自带的 landscape 主题为例。没错，这些东东都是由这个叫做<strong>主题</strong>的东东引起的。</p>
<p>那么应该怎么修改特定主题的内容呢？答案就在<code>./themes/landscape/_config.yml</code>这个文件中。</p>
<ul>
<li><p><strong>导航栏</strong>。打开主页我们会发现 landscape 这个主题只有<code>Home</code>和<code>Archives</code>两项，那么怎么添加呢？文本编辑器打开<code>./themes/landscape/_config.yml</code>文件，在最上方我们可以看到。</p>
<pre><code># Header
menu:
  Home: /
  Archives: /archives
rss: /atom.xml</code></pre>
<p>Okay，我们只需要把想加入导航栏的内容按照上面的格式添加进去即可，例如，我们想添加 About 项。 # Header menu: Home: / Archives: /archives About: /about rss: /atom.xml 注意，<strong>配置文件中的<code>;</code>后必须有一个空格！</strong><code>;</code>后的内容表示访问路径，接下来我们只需要在 <code>blog/source</code>目录下增加一个<code>about</code>文件夹，并在其中添加一个<code>index.md</code>文件，当我们在主页点击 About 后，页面便会跳转到我们刚刚所编辑的这个<code>index.md</code>所生成的静态网页中，<code>index.md</code>的内容可按照个人需求来写。</p></li>
<li><p><strong>评论和分享</strong>。怎么添加 blog 的评论和分享功能呢？blog 中的评论系统国内一般采用“多说”，国外用“Disqus”较多，可根据自己的需求进行配置，以多说为例。<strong>实际上，每个不同的主题有不同的配置方法！</strong>这里，我们只是以 Hexo 预带的 landscape 主题为例。</p></li>
</ul>
<p>访问<a href="http://duoshuo.com/">多说</a>，使用其中一种途径登陆后会有设置<strong>域名</strong>，<strong>名称</strong>和<strong>首页网址</strong>，首页网址填写为我们的<strong>Github page 地址</strong>，如(username.github.io)。 <strong>名称为我们 Github 的 username </strong>。 然后，使用文本编辑器打开<code>/themes/landscape/layout/_partial/article.ejs</code>文件，把</p>
<pre><code>	&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname){ %&gt;
	  &lt;section id=&quot;comments&quot;&gt;
	    &lt;div id=&quot;disqus_thread&quot;&gt;
	      &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;
	    &lt;/div&gt;
	  &lt;/section&gt;
	&lt;% } %&gt;</code></pre>
<p>改为</p>
<pre><code>	&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.duoshuo_shortname){ %&gt;
    &lt;section id=&quot;comments&quot;&gt;
    	&lt;!-- 多说评论框 start --&gt;
    	&lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;&quot; data-title=&quot;&lt;%= post.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div&gt;
    	&lt;!-- 多说评论框 end --&gt;
    	&lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
    var duoshuoQuery = {short_name:&#39;&lt;%= config.duoshuo_shortname %&gt;&#39;};
      (function() {
        var ds = document.createElement(&#39;script&#39;);
        ds.type = &#39;text/javascript&#39;;ds.async = true;
        ds.src = (document.location.protocol == &#39;https:&#39; ? &#39;https:&#39; : &#39;http:&#39;) + &#39;//static.duoshuo.com/embed.js&#39;;
        ds.charset = &#39;UTF-8&#39;;
        (document.getElementsByTagName(&#39;head&#39;)[0] 
         || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(ds);
      })();
      &lt;/script&gt;
    &lt;!-- 多说公共JS代码 end --&gt;
  &lt;/section&gt;
  &lt;% } %&gt;</code></pre>
<p>然后打开根目录的配置文件<code>./_config.yml</code>，在其中加入以下代码。</p>
<p>duoshuo_shortname: username // 这里的username请用 Github 的 username 替换。</p>
<p>分享，<strong>landscape</strong> 主题已经自带了分享功能，但分享的对象都是 <strong>Facebook，Twitter</strong> 等国内不常见的网站，那么应该怎样添加或修改呢？</p>
<p>首先，打开<code>./themes/landscape/source/js/script.js</code>文件，在其中找到如下代码：</p>
<pre><code>	  var html = [
	    &#39;&lt;div id=&quot;&#39; + id + &#39;&quot; class=&quot;article-share-box&quot;&gt;&#39;,
	        &#39;&lt;input class=&quot;article-share-input&quot; value=&quot;&#39; + url + &#39;&quot;&gt;&#39;,
	        &#39;&lt;div class=&quot;article-share-links&quot;&gt;&#39;,
	           &#39;&lt;a href=&quot;https://twitter.com/intent/tweet?url=&#39; + encodedUrl + &#39;&quot; class=&quot;article-share-twitter&quot; target=&quot;_blank&quot; title=&quot;Twitter&quot;&gt;&lt;/a&gt;&#39;,
	           &#39;&lt;a href=&quot;https://www.facebook.com/sharer.php?u=&#39; + encodedUrl + &#39;&quot; class=&quot;article-share-facebook&quot; target=&quot;_blank&quot; title=&quot;Facebook&quot;&gt;&lt;/a&gt;&#39;,
	           &#39;&lt;a href=&quot;http://pinterest.com/pin/create/button/?url=&#39; + encodedUrl + &#39;&quot; class=&quot;article-share-pinterest&quot; target=&quot;_blank&quot; title=&quot;Pinterest&quot;&gt;&lt;/a&gt;&#39;,
	           &#39;&lt;a href=&quot;https://plus.google.com/share?url=&#39; + encodedUrl + &#39;&quot; class=&quot;article-share-google&quot; target=&quot;_blank&quot; title=&quot;Google+&quot;&gt;&lt;/a&gt;&#39;,
	        &#39;&lt;/div&gt;&#39;,
	    &#39;&lt;/div&gt;&#39;
	  ].join(&#39;&#39;);</code></pre>
<p>可以看到其中形如<code>&lt;a href=&quot;https://twitter.com/intent/tweet?url=' + encodedUrl + '&quot; class=&quot;article-share-twitter&quot; target=&quot;_blank&quot; title=&quot;Twitter&quot;&gt;&lt;/a&gt;</code>的即为分享地址，那么我们可以加入国内常用的一些社交工具，如下所示 ’&lt;a href=“http://service.weibo.com/share/share.php?&amp;title=‘+ encodedUrl +’” class=“article-share-sina” target=“_blank&quot; title=“微博”&gt;</a>‘,’<a href="http://share.renren.com/share/buttonshare.do?link=' + encodedUrl + '" class="article-share-renren" target="_blank" title="人人"></a>‘,’<a href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=' + encodedUrl + '" class="article-share-qq" target="_blank" title="QQ 空间"></a>‘,’<a href="http://v.t.qq.com/share/share.php?url=' + encodedUrl + '" class="article-share-tencent" target="_blank" title="腾讯微博"></a>’,</p>
<p>加入代码之后，我们需要加入网站的图标。本主题使用 Font Awesome 来显示图标，但内置的 Font Awesome 版本较旧，无法显示 QQ、腾讯微博等图标，所以，需要下载<a href="http://fortawesome.github.io/Font-Awesome/">最新版 Font Awesome</a>，替换掉<code>source/fonts</code>中相关文件，并在<code>./theme/landscape/source/css/_variables.styl</code>中的<code>font-icon-version</code>修改为最新的 Font Awesome 版本号。</p>
<p>然后，在<code>source/css/_partial/article.styl</code>中，找到以<code>.article-share-***</code>开头的代码，或添加或替换以下内容。</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">.article-share-sina</span>
  <span class="kw">@extend</span> <span class="ot">$article</span>-share-link
  <span class="kw">&amp;</span>:<span class="kw">before</span>
    <span class="kw">content</span>: <span class="st">&quot;\f18a&quot;</span>
  <span class="kw">&amp;</span>:<span class="kw">hover</span>
    <span class="kw">background</span>: color-sina
    <span class="kw">text-shadow</span>: 0 1px darken(color-sina, 20%)

<span class="kw">.article-share-qq</span>
  <span class="kw">@extend</span> <span class="ot">$article</span>-share-link
  <span class="kw">&amp;</span>:<span class="kw">before</span>
    <span class="kw">content</span>: <span class="st">&quot;\f1d6&quot;</span>
  <span class="kw">&amp;</span>:<span class="kw">hover</span>
    <span class="kw">background</span>: color-qq
    <span class="kw">text-shadow</span>: 0 1px darken(color-qq, 20%)

<span class="kw">.article-share-renren</span>
  <span class="kw">@extend</span> <span class="ot">$article</span>-share-link
  <span class="kw">&amp;</span>:<span class="kw">before</span>
    <span class="kw">content</span>: <span class="st">&quot;\f18b&quot;</span>
  <span class="kw">&amp;</span>:<span class="kw">hover</span>
    <span class="kw">background</span>: color-renren
    <span class="kw">text-shadow</span>: 0 1px darken(color-renren, 20%)

<span class="kw">.article-share-tencent</span>
  <span class="kw">@extend</span> <span class="ot">$article</span>-share-link
  <span class="kw">&amp;</span>:<span class="kw">before</span>
    <span class="kw">content</span>: <span class="st">&quot;\f1d5&quot;</span>
  <span class="kw">&amp;</span>:<span class="kw">hover</span>
    <span class="kw">background</span>: color-tencent
    <span class="kw">text-shadow</span>: 0 1px darken(color-tencent, 20%)</code></pre></div>
<p>最后，找到<code>source/css/_variables.styl</code>中<code>Colors</code>部分，最后四行分别为四个社交网站图标的背景色，可根据这些网站的主题色修改。可使用如下修改结果：</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">color-sina</span> = <span class="co">#ea0020</span>
<span class="kw">color-qq</span> = <span class="co">#518adb</span>
<span class="kw">color-renren</span> = <span class="co">#406ccb</span>
<span class="kw">color-tencent</span> = <span class="co">#33b5eb</span></code></pre></div>
<p>每个主题有很多不同的修改方法，关于 landscape 主题的更多修改可以查看<a href="http://blanboom.org/hack-hexo-theme-landscape.html#toc_4">Hexo 主题 Landscape 改造小记</a>。</p>
<ul>
<li>Hexo设置分类和标签</li>
</ul>
<p>大多数时候我们需要为我们所写的 blog 添加分类和标签，那么在 hexo 中应该怎么做呢？</p>
<p>每当我们通过<code>hexo new title</code>新创建一篇博文之后，博文的初始内容会如下图所示：</p>
<pre><code>	title: test go
	date: 2015-06-12 16:14:38
	tags:
	---</code></pre>
<p>可以编辑标题，日期和标签，并没有分类的选项，可以手动加入<code>categories</code>项。然后直接在相应的项后填入我们想要的内容即可。添加多个分类或标签的格式类似，如下所示：</p>
<pre><code>	categories: [categories1,categories2,...]
	tags: [tag1,tag2,...]</code></pre>
<p>当然，为了不必每次创建新的 blog 后手动添加<code>categories</code>项，我们可以修改模板内容，打开<code>/scaffolds/post.md</code>文件，加入<code>categories</code>项即可。</p>
<ul>
<li>Hexo更换主题</li>
</ul>
<p>玩 blog 更换主题必然是很重要的一个方面，那么对于 Hexo来说，我们要怎么更换主题呢？本文以更换 Jacman 主题为例，更换其他主题类似。</p>
<p>首先，找到你想要的主题的地址，绝大多数 Hexo 的主题都托管在 Github 上，那么我们找到所想要主题的 repo url。使用 Git bash 进入到我们本地 blog 的文件夹，然后将主题 clone 到<code>/themes</code>目录下。</p>
<pre><code>	$ git clone https://github.com/wuchong/jacman.git themes/jacman</code></pre>
<p>然后，修改根目录下的<code>_config.yml</code>文件，找到<code>theme</code>属性并将其置为<code>jacman</code>。</p>
<pre><code>	# Extensions
	## Plugins: http://hexo.io/plugins/
	## Themes: http://hexo.io/themes/
	theme: jacman                              # // 主题名称</code></pre>
<p>然后，更新主题即可。</p>
<pre><code>	cd themes/jacman
	git pull origin master</code></pre>
<p>jacman主题提供了丰富的属性配置，可根据个人需要修改配置文件。详情请参考<a href="http://wuchong.me/blog/2014/11/20/how-to-use-jacman/">Jack’s Blog，如何使用Jacman主题</a>。</p>
<p>更多关于hexo的主题，可参考<a href="https://github.com/hexojs/hexo/wiki/themes">Github Hexo Themes</a>，<a href="http://www.zhihu.com/question/24422335">知乎，有哪些好看的hexo主题</a>等等。</p>
<section id="总结" class="level3">
<h3>总结</h3>
<p>这篇博文整合了几份优秀的关于 Hexo 的资源，相应的也已经在文中给出了链接，尽管并没有一些创新的地方，但还是希望能对同学们有一些帮助。</p>
<div class="references">

</div>
</section>
</section>]]></summary>
</entry>
<entry>
    <title>Github page + Hexo ，独立博客我们来了</title>
    <link href="https://xinitrc.de/blog/2015/05/30/hexo-github.html" />
    <id>https://xinitrc.de/blog/2015/05/30/hexo-github.html</id>
    <published>2015-05-30T00:00:00Z</published>
    <updated>2015-05-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>How to build a personal blog based on Github page + Hexo by free ?</p>
<!--more-->
<p>忽然萌生了要写博客的想法，折腾了一天，总算搭配好了环境。这篇文章并不是很详细的教程，但作为一个刚刚实践过的人，我会把我搭配过程中遇到的种种问题在这里讲解出来，希望能对一些同学有所帮助。当然，我同样会在文章中给出实现过程中参考的blog，一知半解的同学可以进行参考。</p>
<p>先说一下我的搭配环境，并没有购买独立域名，而是采用了Github为Github page所分配的二级域名，所以对于想拥有独立blog而又想free of charge的话，那么接着看下去。</p>
<section id="准备工作what-we-need" class="level3">
<h3>准备工作，What we need？</h3>
<hr />
<ul>
<li><a href="https://github.com/">Github 账户</a></li>
<li><a href="https://msysgit.github.io/">Git Shell，windows环境下我使用了Git bash</a></li>
<li><a href="https://nodejs.org/">Node.js</a></li>
<li>文本编辑器，windows下推荐<a href="https://notepad-plus-plus.org/">Notepad++</a> &amp; <a href="http://www.sublimetext.com/">Sublime</a></li>
</ul>
</section>
<section id="创建与配置github" class="level3">
<h3>创建与配置Github</h3>
<hr />
<p>注册Github的过程这里不再多说，不明白的同学可以参考<a href="http://cnfeat.com/2014/05/10/2014-05-11-how-to-build-a-blog/">如何搭建一个独立博客——简明Github Pages与Hexo教程</a>一文。</p>
</section>
<section id="配置ssh-key" class="level2">
<h2>#### 配置SSH key</h2>
<p>老实的讲，我还并没有搞懂SSH key的作用。Someone say 是为了建立local与remote的联系，但是如果不手动配置SSH key，github系统同样会为我们默认生成一个。但为了避免出错，我们还是按部就班的做吧，生命在于折腾。。下面的部分参考<a href="http://beiyuu.com/github-pages/">BeiYuu’s blog</a>。</p>
<p><strong>现在已经明白配置 SSH key 的作用，如果不配置 SSH key，我们每次上传文件至 remote 端的话都需要输入用户名和密码，而配置了 SSH key 之后，我们每次只需要填入设置的密码即可。</strong></p>
<p>首先，检查电脑上现有的ssh key，文件存放位置通常在 <strong>“C: .ssh”</strong> 文件夹中。</p>
<p>然后，生成新的ssh key，在git bash中输入下列命令：</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">ssh-keygen</span> -t rsa -C <span class="st">&quot;邮件地址@youremail.com&quot;</span>
<span class="kw">Generating</span> public/private rsa key pair.
<span class="kw">Enter</span> file in which to save the key (/Users/your_user_directory/.ssh/id_rsa)<span class="kw">:</span>  Click ENTER</code></pre></div>
<p>点击回车后，系统会要求输入密码串：</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">Enter</span> passphrase (empty for no passphrase)<span class="kw">:</span>
<span class="kw">Enter</span> same passphrase again:</code></pre></div>
<p>输入两次密码，看到下图后，标明ssh key设置成功。 <img src="/assets/images/hexogit/sshkeyset.png" alt="" /></p>
<p>接下来，添加ssh key到Github端。打开<strong>“C: .ssh”</strong> 文件夹中<strong>“id_rsa.pub”</strong>文件，可使用notepad++或者sublime文本编辑模式，复制全部内容。登陆Github账户后，点击右上角粉红色按钮，选择settings。 <img src="/assets/images/hexogit/setting.png" alt="" /></p>
<p>进入<strong>personal settings</strong>，选择<strong>SSH keys</strong>，点击<strong>Add SSH key</strong>，将复制的内容粘贴到key中，单击<strong>Add key</strong>即可完成添加。 <img src="/assets/images/hexogit/sshsetting.png" alt="" /></p>
<p>在git bash中输入以下命令，测试是否添加成功。</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">ssh</span> -T git@github.com
<span class="kw">Enter</span> passphrase for key <span class="st">&#39;/c/Users/Limbo/.ssh/id_rsa&#39;</span>:
<span class="kw">Hi</span> ! You<span class="st">&#39;ve successfully authenticated, but Github does not provide shell access.</span></code></pre></div>
</section>
<section id="创建github-page" class="level2">
<h2>#### 创建Github page</h2>
<p>首先登陆Github账户，然后我们便可以创建我们的blog主页了（其实本质上就是一个仓库repository）。点击右上角加号create new repository，如下图所示， <img src="/assets/images/hexogit/createRepo.png" alt="" /> Repository name请填入<code>ownername.github.io</code>，必须注意的是，<strong>Repository name必须与Owner名字一致</strong>。例如此处对于我来说，需填入<code>AaronYee.github.io</code>。其他项不需调整，点击create repository完成创建。</p>
<p>接下来测试一下，引用<a href="https://pages.github.com/">Github page</a>官方主页的例子，首先打开git bash进入工作目录（任意指定），clone下我们刚刚在github端创建好的repository，命令如下： <img src="/assets/images/hexogit/gitclone.png" alt="" /></p>
<p>将其中的<strong>username</strong>那么替换为你的<strong>github name</strong>即可，也可以从repository页面找到clone地址，在github端进入指定repository， <img src="/assets/images/hexogit/repository.png" alt="" /> 点击右侧Copy to clipboard即可复制URL地址。其他选项如上图所示的Clone in Desktop和Download ZIP也同样可以使用。</p>
<p>然后进入本地clone下的repository文件夹，并创建html文件，如下图所示： <img src="/assets/images/hexogit/createhtml.png" alt="" /></p>
<p>Go on，将编辑好的文件上传回Github服务器端。命令如下所示： <img src="/assets/images/hexogit/gitadd.png" alt="" /></p>
<p>关于Git命令这里不再过多阐述，可参考<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Git教程</a>，<a href="http://git-scm.com/book/zh/v1">Pro Git</a>。</p>
<p>提交成功后，可打开浏览器地址栏输入 <strong>http://username.github.io</strong> （username替换为你的repository name）查看是否可以显示出刚才所设置的html文件内容，若成功显示，则证明Github page搭建成功。第一次通常会有一些<strong>延时</strong>，请耐心等待10分钟左右时间。另外请注意，github的<strong>邮箱验证</strong>可能会影响到Github page的搭建，请及时验证邮箱。</p>
<p><strong>Okay，至此，Github端环境搭建完成。</strong></p>
</section>
<section id="安装hexo" class="level2">
<h2>### 安装Hexo</h2>
<p>在安装Node.js的过程中，<strong>请不要修改默认的安装路径</strong>，因为涉及到环境变量的配置问题。成功安装Node.js与Git bash后，在Git bash中输入下述命令即可安装hexo。</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">npm</span> install -g hexo-cli</code></pre></div>
<p>注意，如果在Git bash中提示<code>npm command not found</code>，请切换到windows command中进行安装。</p>
<p>hexo安装完成后，可以创建我们用于写blog的文件夹了，anywhere you want。创建好后，在git bash中输入如下命令，其中<code>&lt;folder&gt;</code>为我们刚刚所创建的文件夹。</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">hexo</span> init <span class="kw">&lt;</span>folder<span class="kw">&gt;</span>      // Initialization，初始化
$ <span class="kw">cd</span> <span class="kw">&lt;</span>folder<span class="kw">&gt;</span>
$ <span class="kw">npm</span> install             // 安装插件</code></pre></div>
<p>打开我们刚刚所建立的文件夹，会发现其中多出了很多内容，这些便是hexo所依赖的信息，具体内容如下所示：</p>
<pre><code>.
├── _config.yml        // 配置文件
├── package.json       // 应用程序的信息
├── scaffolds          // 模板文件夹
├── scripts            // 脚本文件夹
├── source             // 资源文件夹
|   ├── _drafts
|   └── _posts
└── themes             // 主题文件夹</code></pre>
<p>因为我们在写博客的时候，编辑的文件是<strong>“.md”</strong>文件，而在部署到blog的时候，需要生成为<strong>html</strong>文件，这个过程可由下述过程完成。</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">hexo</span> generate        // 最新版本的hexo支持简化形式，即 hexo g</code></pre></div>
<p>执行上述命令后，在我们的blog文件夹中会自动生成一个public文件夹，这个文件夹的内容即是我们需要部署到blog服务器端的内容。接下来，输入下述命令开启本地服务器。</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">hexo</span> server        // 最新版本的hexo支持简化形式，即 hexo s</code></pre></div>
<p>打开浏览器，地址栏中输入<strong>“http://localhost:4000”</strong>，若弹出下列界面，则证明配置成功。 <img src="/assets/images/hexogit/sample.png" alt="" /></p>
<p>现在我们已经完成了本地端的配置，那么接下来<strong>怎样将我们本地写好的blog挂载到服务器上呢</strong>？So easy，用我们上文配置好的<strong>Github page</strong>，这就相当于将我们本地写好的文件上传到Github repository中，然后便可以在Github page下浏览到我们在本地写好的blog了。</p>
<p>上传的过程，我们可以将public文件夹中的所有内容复制到clone下的repository文件夹中，并通过git命令上传。但是，hexo已经帮我们集成好了这个操作。我们只需要配置好环境，便可以实现一键部署。首先，打开我们创建的blog文件夹下，用文本编辑器打开<code>_config.yml</code>文件，在最下方找到<strong>Deployment</strong>选项，将其配置成如下的形式即可。</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># Deployment</span>
<span class="co">## Docs: http://hexo.io/docs/deployment.html</span>
<span class="kw">deploy</span>:
  <span class="kw">type</span>: git
  <span class="kw">repo</span>: https://github.com/username/username.github.io.git
  <span class="kw">branch</span>: master</code></pre></div>
<p>其中的<strong>username</strong>替换为个人的<strong>repository name</strong>。配置完成后，我们即可通过命令一键将所写的内容部署到服务器端。</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">hexo</span> deploy       // 最新版本的hexo支持简化形式，即 hexo d </code></pre></div>
<p>部署过程中会要求我们输入github的用户名和密码，正确输入即可。部署成功后，再次打开浏览器，进入我们上文搞定的Github page界面，<strong>http://username.github.io</strong>，即可看到我们本地写好的文件已经可以成功访问了！</p>
<p>当我们想新写一篇博客的时候，在git bash改变到blog目录的情况下，输入以下命令</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">hexo</span> new [layout] <span class="kw">&lt;</span>title<span class="kw">&gt;</span>       //  layout默认使用_config.yml中的default_layout参数代替，此处可以为空。</code></pre></div>
<p>即可发现<code>./source/_posts</code>文件夹中多出了一个<code>&lt;title&gt;.md</code>文件，使用文本编辑器编辑该文件，按照MarkDown语法格式，即可完成blog的编写。</p>
</section>
<section id="配置hexo" class="level2">
<h2>### 配置Hexo</h2>
<p>Hexo的配置文件集中在主目录下的<code>_config.yml</code>文件中，下面贴出个人的配置文件和注释，可以根据个人的需要进行修改。</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># Hexo Configuration</span>
<span class="co">## Docs: http://hexo.io/docs/configuration.html</span>
<span class="co">## Source: https://github.com/hexojs/hexo/</span>

<span class="co"># Site</span>
<span class="kw">title</span>: Aaron-Yee Blog                       // 网站标题
<span class="kw">subtitle</span>: 专注 <span class="kw">&amp;</span> 沉淀                        <span class="kw">//</span> 网站副标题
<span class="kw">description</span>:                                // 网站描述
<span class="kw">author</span>: Aaron Yee                           // 作者名字
<span class="kw">language</span>: zh-CN                             // 网站使用的语言
<span class="kw">timezone</span>:

<span class="co"># URL</span>
<span class="co">## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;</span>
<span class="kw">url</span>: http://yoursite.com
<span class="kw">root</span>: /
<span class="kw">about_dir</span>: about
<span class="kw">tag_dir</span>: tags
<span class="kw">category_dir</span>: categories
<span class="kw">permalink</span>: :year/:month/:day/:title/
<span class="kw">permalink_defaults</span>:

<span class="co"># Directory                                 // 目录</span>
<span class="kw">source_dir</span>: source                          // 资源文件夹，用来存放内容
<span class="kw">public_dir</span>: public                          // 公共文件夹，用于存放生成的站点文件
<span class="kw">tag_dir</span>: tags                               // 标签文件夹
<span class="kw">archive_dir</span>: archives                       // 归档文件夹
<span class="kw">category_dir</span>: categories                    // 分类文件夹
<span class="kw">code_dir</span>: downloads/code                    // include code 文件夹
<span class="kw">i18n_dir</span>: :lang                             // 国际化(i18n)文件夹
<span class="kw">skip_render</span>:                                // 跳过指定文件的渲染

<span class="co"># Writing                                   // 设置hexo new 时候的相关配置</span>
<span class="kw">new_post_name</span>: :title.md                    // 新文章文件名称 <span class="co"># File name of new posts                </span>
<span class="kw">default_layout</span>: post                        // 预设布局
<span class="kw">titlecase</span>: false                            // 把标题转换为title case <span class="co"># Transform title into titlecase</span>
<span class="kw">external_link</span>: true                         // 在新标签中打开链接 <span class="co"># Open external links in new tab</span>
<span class="kw">filename_case</span>: 0                            // 把文件名称转换为(1)小写或<span class="kw">(2)</span>大写
<span class="kw">render_drafts</span>: false                        // 显示草稿
<span class="kw">post_asset_folder</span>: false                    // 启动Asset文件夹
<span class="kw">relative_link</span>: false                        // 把链接改为与根目录的相对位置
<span class="kw">future</span>: true                                // 显示未来的文章
<span class="kw">highlight</span>:                                  // 代码块设置
  <span class="kw">enable</span>: true
  <span class="kw">line_number</span>: true
  <span class="kw">auto_detect</span>: true
  <span class="kw">tab_replace</span>:

<span class="co"># Category &amp; Tag                            // 分类 &amp; 标签</span>
<span class="kw">default_category</span>: uncategorized
<span class="kw">category_map</span>:
<span class="kw">tag_map</span>:

<span class="co"># Date / Time format</span>
<span class="co">## Hexo uses Moment.js to parse and display date</span>
<span class="co">## You can customize the date format as defined in</span>
<span class="co">## http://momentjs.com/docs/#/displaying/format/</span>
<span class="kw">date_format</span>: YYYY-MM-DD
<span class="kw">time_format</span>: HH:mm:ss

<span class="co"># Pagination</span>
<span class="co">## Set per_page to 0 to disable pagination</span>
<span class="kw">per_page</span>: 10
<span class="kw">pagination_dir</span>: page

<span class="co"># Extensions</span>
<span class="co">## Plugins: http://hexo.io/plugins/</span>
<span class="co">## Themes: http://hexo.io/themes/</span>
<span class="kw">theme</span>: jacman                              // 主题名称

<span class="co"># Deployment                               // 自动部署的配置</span>
<span class="co">## Docs: http://hexo.io/docs/deployment.html</span>
<span class="kw">deploy</span>:
  <span class="kw">type</span>: git
  <span class="kw">repo</span>: https://github.com/AaronYee/AaronYee.github.io.git
  <span class="kw">branch</span>: master</code></pre></div>
<p>更多关于Hexo的信息可以在<a href="http://hexo.io/zh-cn/">hexo</a>中查看。</p>
</section>
<section id="更换hexo主题" class="level2">
<h2>### 更换Hexo主题</h2>
<p>很显然，玩blog，主题是很重要的一个方面，那么怎么样<strong>更换Hexo的主题</strong>呢？本文以<strong>jacman</strong>主题为例，下文转自<a href="http://wuchong.me/blog/2014/11/20/how-to-use-jacman/">Jack’s Blog，如何使用Jacman主题</a>。</p>
<p>首先，使用Git bash进入本机的blog根目录，然后执行以下命令。</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> clone https://github.com/wuchong/jacman.git themes/jacman</code></pre></div>
<p>Jacman 需要安装 Hexo 2.7 及以上版本，请先升级您的 Hexo 程序，再启用此主题。</p>
<p>然后，修改根目录下的<code>_config.yml</code>配置文件中的<code>theme</code>属性，将其设置为<code>jacman</code>。</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># Extensions</span>
<span class="co">## Plugins: http://hexo.io/plugins/</span>
<span class="co">## Themes: http://hexo.io/themes/</span>
<span class="kw">theme</span>: jacman                              // 主题名称</code></pre></div>
<p>然后更新主题</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">cd</span> themes/jacman
<span class="kw">git</span> pull origin master</code></pre></div>
<p>jacman主题提供了丰富的属性配置，可根据个人需要修改配置文件。详情请参考<a href="http://wuchong.me/blog/2014/11/20/how-to-use-jacman/">Jack’s Blog，如何使用Jacman主题</a>。</p>
<p>更多关于hexo的主题，可参考<a href="https://github.com/hexojs/hexo/wiki/themes">Github Hexo Themes</a>，<a href="http://www.zhihu.com/question/24422335">知乎，有哪些好看的hexo主题</a>等等。</p>
</section>
<section id="总结" class="level2">
<h2>### 总结</h2>
<p>总结一下实践过程中遇到的几个问题，希望能对后来的同学有所帮助。</p>
<ul>
<li><strong>Q. 上传本地repository到github端时，执行命令<code>git remote add origin</code>时出现 fatal: remote origin already exists 错误。</strong> &gt; 请先执行命令<code>git remote rm origin</code>，然后再重新添加。</li>
<li><strong>Q. 上传本地repository到github端时，执行命令<code>git push origin master</code>时出现 error: failed to push som refs to… 错误。</strong> &gt; 可执行命令 <code>git pull origin master</code> 将远程文件拉下来再push。</li>
<li><strong>Q. 打开<code>http://localhost:4000</code>只看到一堆代码，并没有预想中的网页出现。</strong> &gt; 这可能是由于hexo并没有对网页代码进行动态解析，请在git bash的blog根目录下重新输入<code>npm install</code>生成依赖的插件包。</li>
<li><strong>Q. 打开<code>username.github.io</code>的时候，并没有显示出于本地server浏览同样的效果。</strong> &gt; 有部分原因可能是Github有延迟的原因，请稍后再试。若还是出现问题，请细心检查配置文件<code>_config.yml</code>。</li>
<li><strong>Q. 使用Jacman主题，修改配置文件后并没有出现预想的效果。</strong> &gt; 注意修改配置文件时，<code>_config.yml</code>文件中的每个属性值前必须留一个空格。请务必注意缩进问题，尽量保持与原文档格式一致，相应项对齐。</li>
<li><strong>Q. Blog内容中想加入配图，图片文件应该放在哪个文件夹中。</strong> &gt; Markdown插入图片的格式为<code>![](图片地址){ImgCap}图片标题{/ImgCap}</code>，外部链接图片直接在图片地址中填入，本地图片可在本地blog根目录的<code>./source/</code>文件夹中新建一个文件夹images用来存放图片，然后插入图片时图片地址为<code>/imgages/Fig1.png</code>。</li>
</ul>
<div class="references">

</div>
</section>]]></summary>
</entry>

</feed>
